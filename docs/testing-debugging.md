---
title: Testing & Debugging Guide
description: Comprehensive guide to testing and debugging MCP servers with npm scripts, MCP Inspector, and advanced debugging techniques.
keywords: [testing, debugging, MCP Inspector, npm scripts, unit tests, integration tests, stdio testing, HTTP testing]
---

# Testing & Debugging Guide

Comprehensive testing and debugging capabilities are built into every MCP server generated by `mcp-server-generator`. This guide covers all testing methods, debugging techniques, and troubleshooting strategies.

## Quick Testing Overview

Every generated MCP server includes convenient testing commands:

```bash
# ğŸš€ Quick overview of all capabilities
npm run quick:test          # Shows ALL tools, resources & prompts

# ğŸ”§ Component-specific testing
npm run test:tools          # List and test all tools
npm run test:resources      # List and test all resources  
npm run test:prompts        # List and test all prompts

# ğŸ¯ Development servers
npm run dev:stdio           # Start stdio transport (Claude Desktop)
npm run dev:http            # Start HTTP transport (web/Cursor)
npm run dev:http:stateless  # HTTP stateless mode (best for Inspector)

# ğŸ” MCP Inspector testing
npm run inspector           # Launch visual inspector (UI mode)
npm run inspector:cli       # Command line testing interface

# ğŸ“‹ General help
npm run help               # Show all available commands
```

## Component Testing

### Testing Tools

Tools are the core functionality of your MCP server. Test them thoroughly:

```bash
# List all available tools
npm run test:tools
```

**Sample Output:**
```
ğŸ› ï¸  Available Tools:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

âœ… data-analysis
   ğŸ“ Complete data analysis with multiple methodologies
   ğŸ“‹ Inputs: data, methodology, sampleSize, confidenceLevel

âœ… calculator
   ğŸ“ Perform mathematical calculations
   ğŸ“‹ Inputs: expression, precision

âœ… server-status  
   ğŸ“ Get server health and performance information
   ğŸ“‹ Inputs: includeMetrics, format

âœ… start-elicitation
   ğŸ“ Begin interactive information gathering process
   ğŸ“‹ Inputs: topic, context, goals

ğŸ’¡ To test a tool: npm run inspector:cli -- --tool <tool-name>
```

### Testing Resources

Resources provide data and documentation:

```bash
# List all available resources
npm run test:resources
```

**Sample Output:**
```
ğŸ“‹ Available Resources:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

âœ… data-analysis-guide
   ğŸ“ Comprehensive guide for data analysis methodologies
   ğŸ”— URI: analysis://guide
   ğŸ“„ Type: text/markdown

âœ… server-info
   ğŸ“ Server configuration and runtime information
   ğŸ”— URI: server://info  
   ğŸ“„ Type: application/json

âœ… user-guide
   ğŸ“ Complete user documentation and examples
   ğŸ”— URI: userguide://info
   ğŸ“„ Type: text/markdown

ğŸ’¡ To access a resource: npm run inspector:cli -- --resource <resource-uri>
```

### Testing Prompts

Prompts generate intelligent templates:

```bash
# List all available prompts
npm run test:prompts
```

**Sample Output:**
```
ğŸ’¡ Available Prompts:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

âœ… research-analysis
   ğŸ“ Generate research analysis prompts with multiple methodologies
   ğŸ“‹ Arguments: topic, methodology, context, scope

âœ… interactive-exploration
   ğŸ“ Create guided exploration questions
   ğŸ“‹ Arguments: domain, focus, depth

âœ… code-review
   ğŸ“ Generate comprehensive code review templates
   ğŸ“‹ Arguments: code, language, reviewType

ğŸ’¡ To test a prompt: npm run inspector:cli -- --prompt <prompt-name>
```

## MCP Inspector Testing

The MCP Inspector provides powerful visual and CLI testing capabilities.

### Visual Inspector (UI Mode)

Launch the visual interface for comprehensive testing:

```bash
# Start your server in stateless HTTP mode (best for Inspector)
npm run dev:http:stateless

# In another terminal, launch the Inspector
npm run inspector
```

This opens a web interface where you can:
- ğŸ“‹ **View all components** - tools, resources, prompts
- ğŸ§ª **Interactive testing** - test tools with custom inputs
- ğŸ“Š **Response visualization** - formatted output display
- ğŸ” **Request/response inspection** - debug communication
- âš¡ **Real-time updates** - live server testing

### Command Line Inspector

For script-friendly testing and CI/CD integration:

```bash
# Test a specific tool
npm run inspector:cli -- --tool calculator --args '{"expression": "2+2*3", "precision": 2}'

# Test a resource
npm run inspector:cli -- --resource "server://info"

# Test a prompt
npm run inspector:cli -- --prompt research-analysis --args '{"topic": "AI Ethics", "methodology": "qualitative"}'

# List all available components
npm run inspector:cli -- --list-all
```

### Advanced Inspector Usage

Configure Inspector for different scenarios:

```bash
# Test with specific server configuration
npm run inspector:config -- --server my-server-http

# Test stdio transport (for Claude Desktop integration)
npm run inspector:config -- --server my-server-stdio

# Custom Inspector configuration
cat > mcp-inspector.config.json << EOF
{
  "servers": {
    "my-server-dev": {
      "command": "tsx",
      "args": ["src/server.ts", "--debug"],
      "env": {"LOG_LEVEL": "debug"}
    },
    "my-server-prod": {
      "url": "http://localhost:3000",
      "type": "http",
      "headers": {"Authorization": "Bearer token123"}
    }
  }
}
EOF
```

## Development Server Testing

### Stdio Transport Testing

Perfect for Claude Desktop integration testing:

```bash
# Start stdio server
npm run dev:stdio

# In another terminal, test with manual input
echo '{"jsonrpc":"2.0","id":1,"method":"tools/list","params":{}}' | npm run dev:stdio

# Test with MCP Inspector CLI
npx @modelcontextprotocol/inspector \
  --cli tsx src/server.ts \
  --method tools/call \
  --tool-name calculator \
  --tool-arg 'expression=5*5'
```

### HTTP Transport Testing

Great for web services and Cursor integration:

```bash
# Start HTTP server
npm run dev:http

# Test with curl
curl -X POST http://localhost:3000/mcp \
  -H "Content-Type: application/json" \
  -d '{"jsonrpc":"2.0","id":1,"method":"tools/list","params":{}}'

# Test specific tool
curl -X POST http://localhost:3000/mcp \
  -H "Content-Type: application/json" \
  -d '{
    "jsonrpc":"2.0",
    "id":1,
    "method":"tools/call",
    "params":{
      "name":"calculator",
      "arguments":{"expression":"10+5*2"}
    }
  }'

# Health check endpoint
curl http://localhost:3000/health
```

### Stateless HTTP Testing

Ideal for Inspector and testing environments:

```bash
# Start stateless HTTP server
npm run dev:http:stateless

# Benefits:
# - No session management
# - Faster response times
# - Better for automated testing
# - Perfect for MCP Inspector
```

## Unit Testing

### Running Unit Tests

```bash
# Run all tests
npm test

# Run tests with coverage
npm run test:coverage

# Run tests in watch mode
npm run test:watch

# Run specific test files
npm test -- --testPathPattern=calculator-tool

# Run tests with verbose output
npm test -- --verbose
```

### Test Structure

Generated projects include comprehensive test setup:

```
tests/
â”œâ”€â”€ tools/
â”‚   â”œâ”€â”€ calculator-tool.test.ts
â”‚   â”œâ”€â”€ data-analysis-tool.test.ts
â”‚   â””â”€â”€ server-status-tool.test.ts
â”œâ”€â”€ resources/
â”‚   â”œâ”€â”€ data-analysis-resource.test.ts
â”‚   â””â”€â”€ server-info-resource.test.ts
â”œâ”€â”€ prompts/
â”‚   â””â”€â”€ research-analysis-prompt.test.ts
â”œâ”€â”€ integration/
â”‚   â”œâ”€â”€ full-workflow.test.ts
â”‚   â””â”€â”€ transport-integration.test.ts
â”œâ”€â”€ fixtures/
â”‚   â”œâ”€â”€ sample-data.json
â”‚   â””â”€â”€ test-configs.ts
â””â”€â”€ test-utils.ts
```

### Example Test Implementation

```typescript title="tests/tools/calculator-tool.test.ts"
import { describe, it, expect, beforeEach } from '@jest/globals';
import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
import { CalculatorTool } from '../../src/tools/calculator-tool.js';

describe('CalculatorTool', () => {
  let server: McpServer;
  let tool: CalculatorTool;

  beforeEach(() => {
    server = new McpServer();
    tool = new CalculatorTool();
    tool.register(server);
  });

  it('should perform basic calculations', async () => {
    const result = await server.callTool('calculator', {
      expression: '2 + 2',
      precision: 0
    });

    expect(result.content[0].text).toContain('4');
  });

  it('should handle complex expressions', async () => {
    const result = await server.callTool('calculator', {
      expression: '(10 + 5) * 2 - 8',
      precision: 2
    });

    expect(result.content[0].text).toContain('22.00');
  });

  it('should handle invalid expressions', async () => {
    const result = await server.callTool('calculator', {
      expression: 'invalid math',
      precision: 2
    });

    expect(result.content[0].text).toContain('Error');
  });
});
```

## Integration Testing

### Full Workflow Testing

Test complete workflows end-to-end:

```typescript title="tests/integration/data-analysis-workflow.test.ts"
import { describe, it, expect } from '@jest/globals';
import { createTestServer } from '../test-utils.js';

describe('Data Analysis Workflow', () => {
  it('should complete full analysis workflow', async () => {
    const server = createTestServer();
    
    // 1. Start elicitation
    const elicitationResult = await server.callTool('start-elicitation', {
      topic: 'Customer satisfaction analysis',
      context: 'E-commerce platform',
      goals: ['Identify pain points', 'Measure satisfaction']
    });
    
    expect(elicitationResult.content[0].text).toContain('session started');
    
    // 2. Generate sample data
    const sampleResult = await server.callTool('generate-sample', {
      populationSize: 1000,
      sampleSize: 100,
      strategy: 'stratified'
    });
    
    expect(sampleResult.content[0].text).toContain('sample generated');
    
    // 3. Perform analysis
    const analysisResult = await server.callTool('data-analysis', {
      data: sampleResult.data,
      methodology: 'descriptive',
      confidenceLevel: 0.95
    });
    
    expect(analysisResult.content[0].text).toContain('Analysis Results');
  });
});
```

### Transport Integration Testing

Test different transport mechanisms:

```typescript title="tests/integration/transport-integration.test.ts"
import { describe, it, expect } from '@jest/globals';
import { startServer, stopServer } from '../test-utils.js';

describe('Transport Integration', () => {
  it('should handle stdio transport', async () => {
    const server = await startServer('stdio');
    
    const response = await server.sendRequest({
      jsonrpc: '2.0',
      id: 1,
      method: 'tools/list',
      params: {}
    });
    
    expect(response.result.tools).toBeDefined();
    expect(response.result.tools.length).toBeGreaterThan(0);
    
    await stopServer(server);
  });

  it('should handle HTTP transport', async () => {
    const server = await startServer('http');
    
    const response = await fetch('http://localhost:3000/mcp', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        jsonrpc: '2.0',
        id: 1,
        method: 'tools/list',
        params: {}
      })
    });
    
    const data = await response.json();
    expect(data.result.tools).toBeDefined();
    
    await stopServer(server);
  });
});
```

## Debugging Techniques

### Verbose Logging

Enable detailed logging for debugging:

```bash
# Start with debug logging
LOG_LEVEL=debug npm run dev:stdio

# Start with trace logging (most verbose)
LOG_LEVEL=trace npm run dev:http

# Custom logging configuration
cat > src/config/debug.ts << EOF
export const debugConfig = {
  logging: {
    level: 'debug',
    format: 'pretty',
    timestamp: true,
    requestId: true
  }
};
EOF
```

### Error Handling and Debugging

```typescript title="src/utils/debug-helpers.ts"
export function createDebugTool(toolName: string, implementation: Function) {
  return async (args: any) => {
    const startTime = Date.now();
    console.log(`ğŸš€ [${toolName}] Starting with args:`, args);
    
    try {
      const result = await implementation(args);
      const duration = Date.now() - startTime;
      console.log(`âœ… [${toolName}] Completed in ${duration}ms`);
      return result;
    } catch (error) {
      const duration = Date.now() - startTime;
      console.error(`âŒ [${toolName}] Failed after ${duration}ms:`, error);
      throw error;
    }
  };
}
```

### Memory and Performance Debugging

```bash
# Start with Node.js debugging flags
node --inspect --max-old-space-size=4096 lib/server.js

# Memory usage monitoring
node --trace-gc lib/server.js

# CPU profiling
node --prof lib/server.js

# Heap snapshot analysis
node --heap-prof lib/server.js
```

### Network Debugging

```bash
# Monitor HTTP traffic
npm run dev:http -- --debug-network

# Test connectivity
curl -v http://localhost:3000/health

# WebSocket debugging (if using WebSocket transport)
wscat -c ws://localhost:3000/ws
```

## Troubleshooting Common Issues

### Component Registration Issues

```bash
# Check if components are properly registered
npm run quick:test

# Verify component files exist
ls -la src/tools/
ls -la src/resources/
ls -la src/prompts/

# Check for TypeScript compilation errors
npx tsc --noEmit
```

### Transport Issues

**Stdio Transport Problems:**
```bash
# Test stdio manually
echo '{"jsonrpc":"2.0","id":1,"method":"ping","params":{}}' | npm run dev:stdio

# Check for proper stdio handling
npm run dev:stdio --debug-stdio
```

**HTTP Transport Problems:**
```bash
# Check if port is available
netstat -an | grep 3000

# Test HTTP endpoint directly
curl -v http://localhost:3000/health

# Check CORS issues
curl -H "Origin: http://localhost:3001" http://localhost:3000/health
```

### Performance Issues

```bash
# Profile server performance
npm run dev:http -- --profile

# Monitor resource usage
top -p $(pgrep -f "node.*server")

# Analyze bundle size
npm run build -- --analyze
```

### Memory Leaks

```bash
# Monitor memory usage over time
while true; do
  ps aux | grep node | grep server
  sleep 5
done

# Generate heap dumps
kill -USR2 $(pgrep -f "node.*server")

# Analyze heap dumps with Chrome DevTools
node --inspect lib/server.js
```

## Continuous Integration Testing

### GitHub Actions Setup

```yaml title=".github/workflows/test.yml"
name: Test MCP Server

on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    
    strategy:
      matrix:
        node-version: [18, 20]
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Setup Node.js
      uses: actions/setup-node@v3
      with:
        node-version: ${{ matrix.node-version }}
        cache: 'npm'
    
    - name: Install dependencies
      run: npm ci
    
    - name: Build project
      run: npm run build
    
    - name: Run unit tests
      run: npm test -- --coverage
    
    - name: Run integration tests
      run: npm run test:integration
    
    - name: Test MCP Inspector integration
      run: |
        npm run dev:http:stateless &
        sleep 5
        npm run inspector:cli -- --test-all
        pkill -f "node.*server"
```

### Pre-commit Testing

```bash
# Install pre-commit hooks
npm install --save-dev husky lint-staged

# Setup pre-commit script
cat > .husky/pre-commit << EOF
#!/bin/sh
npm run build
npm test
npm run quick:test
EOF

chmod +x .husky/pre-commit
```

## Best Practices

### Testing Strategy

1. **Start with quick tests** - `npm run quick:test` for overview
2. **Use component tests** - test tools, resources, prompts individually
3. **Integration testing** - test complete workflows
4. **Performance testing** - monitor resource usage and response times
5. **Error scenario testing** - test failure modes and error handling

### Debugging Workflow

1. **Quick verification** - `npm run quick:test`
2. **Component isolation** - test specific components
3. **Transport testing** - verify communication layers
4. **Logging analysis** - enable verbose logging
5. **Performance profiling** - identify bottlenecks

### Monitoring and Observability

```typescript title="src/utils/monitoring.ts"
export class ServerMonitoring {
  static trackToolUsage(toolName: string, duration: number) {
    console.log(`ğŸ“Š Tool '${toolName}' executed in ${duration}ms`);
  }
  
  static trackResourceAccess(resourceUri: string) {
    console.log(`ğŸ“‹ Resource '${resourceUri}' accessed`);
  }
  
  static trackErrors(error: Error, context: string) {
    console.error(`âŒ Error in ${context}:`, error);
  }
}
```

## Next Steps

Master testing and debugging to build reliable MCP servers:

- **[Component Development](./components/overview.md)** - Build robust components
- **[Integration Tutorials](./tutorials-and-examples.md)** - Step-by-step integration guides
- **[CLI Commands](./cli-commands.md)** - Master all available commands
- **[Performance Optimization](./api/overview.md)** - Optimize your server performance

Effective testing and debugging ensure your MCP server works reliably in production! ğŸ”§âœ…
